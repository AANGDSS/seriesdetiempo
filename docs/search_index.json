[["unidad-2-análisis-temporal-pib-per-cápita.html", "Capítulo 2 Unidad 2 — Análisis temporal (PIB per cápita) 2.1 Librerías 2.2 Descarga y preparación de PIB per cápita (serie estable) 2.3 Serie principal (Colombia) y gráfico base 2.4 Promedio móvil (suavizamiento) 2.5 Rezagos y ACF (dependencia temporal) 2.6 Estacionalidad (discusión)", " Capítulo 2 Unidad 2 — Análisis temporal (PIB per cápita) En esta unidad se realiza un análisis exploratorio de PIB per cápita (Banco Mundial, 1960–2022) para países LATAM (COL, MEX, BRA, CHL, ARG), con: - Promedio móvil (suavizamiento), - Rezagos y ACF (dependencia temporal), - Discusión de estacionalidad (serie anual, no hay estacionalidad intra-anual). Nota: El API del Banco Mundial está devolviendo intermitentemente “indicator not found” para CO₂. Para no bloquear la entrega, la serie principal de la Unidad 2 será PIB per cápita (NY.GDP.PCAP.CD). Al final añadimos un chunk opcional que intenta traer CO₂ per cápita (EN.ATM.CO2E.PC) con códigos de país en mayúsculas; si funciona, se muestra un gráfico PIB–CO₂ como “tiempo variable complementaria”. Si no, la compilación no se rompe. 2.1 Librerías library(WDI) # fuente Banco Mundial (WDI) library(wbstats) # otra interfaz al API del Banco Mundial library(dplyr) library(ggplot2) library(zoo) library(forecast) 2.2 Descarga y preparación de PIB per cápita (serie estable) # Descargar PIB per cápita (US$ actuales) por país, garantizando MAYÚSCULAS paises &lt;- c(&quot;COL&quot;,&quot;MEX&quot;,&quot;BRA&quot;,&quot;CHL&quot;,&quot;ARG&quot;) years &lt;- 1960:2022 get_gdp_pc &lt;- function(cc) { WDI(country = toupper(cc), indicator = c(gdp = &quot;NY.GDP.PCAP.CD&quot;), start = min(years), end = max(years)) } lst_gdp &lt;- lapply(paises, get_gdp_pc) dat_gdp &lt;- bind_rows(lst_gdp) # Limpiar y ordenar dat_gdp &lt;- dat_gdp %&gt;% transmute(country, iso2c, iso3c, year = as.integer(year), gdp) %&gt;% arrange(country, year) # Verificación rápida stopifnot(&quot;gdp&quot; %in% names(dat_gdp)) head(dat_gdp) ## country iso2c iso3c year gdp ## 1 Argentina AR ARG 1960 778.2517 ## 2 Argentina AR ARG 1961 971.3380 ## 3 Argentina AR ARG 1962 870.2175 ## 4 Argentina AR ARG 1963 852.9724 ## 5 Argentina AR ARG 1964 1176.2009 ## 6 Argentina AR ARG 1965 1281.8334 range(dat_gdp$year) ## [1] 1960 2022 2.3 Serie principal (Colombia) y gráfico base gdp_col &lt;- dat_gdp %&gt;% filter(country == &quot;Colombia&quot;) %&gt;% arrange(year) ggplot(gdp_col, aes(year, gdp)) + geom_line(linewidth = 1, color = &quot;steelblue&quot;) + geom_point(size = 1.5) + labs(title = &quot;PIB per cápita — Colombia (1960–2022)&quot;, x = &quot;Año&quot;, y = &quot;US$ actuales por persona&quot;) + theme_minimal() 2.4 Promedio móvil (suavizamiento) gdp_col &lt;- gdp_col %&gt;% mutate(ma5 = zoo::rollmean(gdp, k = 5, fill = NA, align = &quot;right&quot;)) ggplot(gdp_col, aes(year)) + geom_line(aes(y = gdp), color = &quot;gray60&quot;) + geom_line(aes(y = ma5), color = &quot;red&quot;, linewidth = 1) + labs(title = &quot;PIB per cápita y promedio móvil (5 años)&quot;, x = &quot;Año&quot;, y = &quot;US$ actuales por persona&quot;) + theme_minimal() ## Warning: Removed 4 rows containing missing values or values outside the scale range ## (`geom_line()`). 2.5 Rezagos y ACF (dependencia temporal) gdp_col &lt;- gdp_col %&gt;% mutate(gdp_lag1 = dplyr::lag(gdp, 1)) ggplot(gdp_col, aes(gdp_lag1, gdp)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;red&quot;) + labs(title = &quot;PIB per cápita: gdp(t) vs gdp(t−1)&quot;, x = &quot;PIB per cápita año t−1&quot;, y = &quot;PIB per cápita año t&quot;) + theme_minimal() ## `geom_smooth()` using formula = &#39;y ~ x&#39; ## Warning: Removed 1 row containing non-finite outside the scale range ## (`stat_smooth()`). ## Warning: Removed 1 row containing missing values or values outside the scale range ## (`geom_point()`). ts_gdp &lt;- ts(gdp_col$gdp, start = min(gdp_col$year), frequency = 1) acf(ts_gdp, main = &quot;ACF — PIB per cápita (anual)&quot;) 2.6 Estacionalidad (discusión) La serie es anual (frecuencia 1), por lo que no existe estacionalidad intra-anual. La dinámica observable es de tendencia/ciclos de largo plazo. Para estacionalidad clásica se requerirían datos mensuales o trimestrales. ## Tiempo como variable complementaria: PIB vs CO₂ # Tiempo como variable complementaria: PIB vs CO₂ show_co2_plot &lt;- FALSE # Intento 1: CO₂ per cápita directo por país (códigos MAYÚSCULAS) safe_get_pc &lt;- function(cc) { try( wb_data( indicator = c(co2 = &quot;EN.ATM.CO2E.PC&quot;), country = toupper(cc), start_date = min(years), end_date = max(years), return_wide = TRUE ), silent = TRUE ) } lst_co2 &lt;- lapply(paises, safe_get_pc) # Validar que al menos uno devolvió &#39;co2&#39; con datos no-NA valid_frames &lt;- lapply(lst_co2, function(x) { is.data.frame(x) &amp;&amp; &quot;co2&quot; %in% names(x) &amp;&amp; any(!is.na(x$co2)) }) if (any(unlist(valid_frames))) { co2_ok &lt;- bind_rows(lst_co2[unlist(valid_frames)]) %&gt;% transmute(country, iso2c, iso3c, year = as.integer(date), co2) %&gt;% arrange(country, year) # Unir con PIB dat_join &lt;- inner_join(co2_ok, dat_gdp, by = c(&quot;country&quot;,&quot;iso2c&quot;,&quot;iso3c&quot;,&quot;year&quot;)) if (nrow(dat_join) &gt; 0) { show_co2_plot &lt;- TRUE co2_countries &lt;- intersect(unique(dat_join$country), unique(dat_gdp$country)) # message(&quot;CO₂ disponible para: &quot;, paste(co2_countries, collapse = &quot;, &quot;)) ggplot(dat_join %&gt;% filter(country %in% co2_countries), aes(gdp, co2, group = country, color = year)) + geom_path(linewidth = 1) + scale_x_log10() + labs(title = &quot;PIB per cápita vs CO₂ per cápita (si API responde)&quot;, x = &quot;PIB per cápita (US$ actuales, log)&quot;, y = &quot;CO₂ per cápita (t/persona·año)&quot;) + theme_minimal() } } if (!show_co2_plot) { message(&quot;No se pudo obtener CO₂ per cápita en este intento; el análisis principal usa PIB per cápita.&quot;) } ## No se pudo obtener CO₂ per cápita en este intento; el análisis principal usa PIB per cápita. # Descomposición (anual sin estacionalidad), estacionariedad y diferenciación # Cargar paquetes (asegúrate de tenerlos instalados previamente) library(tseries) ## Warning: package &#39;tseries&#39; was built under R version 4.4.3 library(urca) ## Warning: package &#39;urca&#39; was built under R version 4.4.3 library(dplyr) # 1) Serie de Colombia en log (control de variabilidad) if (!exists(&quot;gdp_col&quot;)) { gdp_col &lt;- dat_gdp %&gt;% filter(country == &quot;Colombia&quot;) %&gt;% arrange(year) } gdp_col &lt;- gdp_col %&gt;% mutate(log_gdp = log(gdp)) ts_log &lt;- ts(gdp_col$log_gdp, start = min(gdp_col$year, na.rm = TRUE), frequency = 1) # anual ⇒ sin estacionalidad # 2) &quot;Descomposición&quot; compatible con frecuencia 1: # Tendencia por LOESS + Residuo = log(PIB) - Tendencia df_loess &lt;- data.frame(year = gdp_col$year, log_gdp = as.numeric(ts_log)) fit &lt;- loess(log_gdp ~ year, data = df_loess, span = 0.3, degree = 1) trend &lt;- ts(predict(fit, newdata = df_loess), start = start(ts_log), frequency = frequency(ts_log)) remainder &lt;- ts_log - trend # Gráfico de los tres componentes op &lt;- par(mfrow = c(3,1), mar = c(3,4,2,1)) plot(ts_log, main = &quot;log(PIB per cápita) — Colombia&quot;, ylab = &quot;log(US$)&quot;) plot(trend, main = &quot;Tendencia (LOESS)&quot;, ylab = &quot;log(US$)&quot;) plot(remainder, main = &quot;Residuo&quot;, ylab = &quot;log(US$)&quot;) par(op) # 3) Estacionariedad (log nivel) adf_log &lt;- tseries::adf.test(na.omit(ts_log), k = 1) # H0: raíz unitaria kpss_log &lt;- urca::ur.kpss(na.omit(ts_log), type = &quot;tau&quot;) # H0: estacionaria (tendencia) list( ADF_p_value_log = adf_log$p.value, KPSS_stat_log = kpss_log@teststat, KPSS_critical_log = kpss_log@cval ) ## $ADF_p_value_log ## [1] 0.4985886 ## ## $KPSS_stat_log ## [1] 0.1110845 ## ## $KPSS_critical_log ## 10pct 5pct 2.5pct 1pct ## critical values 0.119 0.146 0.176 0.216 # 4) Diferenciación (Δlog ⇒ aprox. crecimiento %) diff_log &lt;- diff(ts_log) op &lt;- par(mfrow = c(2,2), mar = c(3,4,2,1)) plot(ts_log, main = &quot;Serie log(PIB pc)&quot;, ylab = &quot;log(US$)&quot;) plot(diff_log, main = &quot;Primera diferencia&quot;, ylab = &quot;Δlog(US$)&quot;) acf (diff_log, main = &quot;ACF Δlog(PIB pc)&quot;) pacf(diff_log, main = &quot;PACF Δlog(PIB pc)&quot;) par(op) # 5) Estacionariedad (serie diferenciada) adf_diff &lt;- tseries::adf.test(na.omit(diff_log), k = 1) ## Warning in tseries::adf.test(na.omit(diff_log), k = 1): p-value smaller than ## printed p-value kpss_diff &lt;- urca::ur.kpss(na.omit(diff_log), type = &quot;mu&quot;) # H0: estacionaria (nivel) list( ADF_p_value_diff = adf_diff$p.value, KPSS_stat_diff = kpss_diff@teststat, KPSS_critical_diff = kpss_diff@cval ) ## $ADF_p_value_diff ## [1] 0.01 ## ## $KPSS_stat_diff ## [1] 0.09509794 ## ## $KPSS_critical_diff ## 10pct 5pct 2.5pct 1pct ## critical values 0.347 0.463 0.574 0.739 Descomposición: al ser anual (frecuencia = 1), no existe estacionalidad. Se estimó una tendencia mediante LOESS y se definió el residuo como la parte no explicada por la tendencia. Estacionariedad: en log(nivel) la serie no es estacionaria (tendencia marcada; ADF no rechaza H0 y/o KPSS rechaza H0 al 5%). Diferenciación: con Δlog la serie se vuelve compatible con estacionariedad (ADF rechaza H0 y KPSS no rechaza H0). Transformaciones necesarias: log para estabilizar variabilidad y diferencia de orden 1 para remover tendencia; esto prepara la serie para modelos ARIMA/ETS. Conclusiones: La serie anual de PIB per cápita presenta una tendencia creciente sostenida y no muestra estacionalidad al ser de frecuencia 1 (anual). Se aplicó una transformación logarítmica para estabilizar la varianza y expresar la dinámica en términos relativos (proporcionales). Las pruebas ADF y KPSS confirman que la serie no es estacionaria en niveles, pero sí lo es tras una primera diferenciación del logaritmo, que equivale al crecimiento porcentual anual del PIB per cápita. Por tanto, las transformaciones log() y Δlog() son necesarias y justificadas para preparar la serie hacia modelado ARIMA/ETS. El análisis indica que la estructura temporal del PIB per cápita colombiano está dominada por una tendencia de largo plazo asociada a crecimiento económico, sin evidencia de ciclos regulares o estacionalidad recurrente. # --- Serie base (Colombia) en log para estabilizar variabilidad --- if (!exists(&quot;dat_gdp&quot;)) stop(&quot;dat_gdp no existe en el entorno.&quot;) if (!exists(&quot;gdp_col&quot;)) { gdp_col &lt;- dat_gdp %&gt;% filter(country == &quot;Colombia&quot;) %&gt;% arrange(year) } ts_log &lt;- ts(log(gdp_col$gdp), start = min(gdp_col$year, na.rm = TRUE), frequency = 1) # anual (sin estacionalidad intra-anual) # --- Partición entrenamiento/prueba --- n &lt;- length(ts_log) h &lt;- min(10, max(3, floor(n * 0.15))) # horizonte: hasta 10 años, al menos 3 train &lt;- window(ts_log, end = time(ts_log)[n - h]) test &lt;- window(ts_log, start = time(ts_log)[n - h + 1]) # --- Modelos ETS sin estacionalidad --- fit_ses &lt;- ets(train, model = &quot;ANN&quot;) # SES fit_holt &lt;- ets(train, model = &quot;AAN&quot;) # Holt (tendencia) fit_dmp &lt;- ets(train, model = &quot;AAN&quot;, damped = TRUE) # Holt amortiguado (damped) # --- Pronósticos --- fc_ses &lt;- forecast(fit_ses, h = h) fc_holt &lt;- forecast(fit_holt, h = h) fc_dmp &lt;- forecast(fit_dmp, h = h) # --- Métricas de evaluación (en log) --- acc &lt;- rbind( SES = accuracy(fc_ses, test), Holt = accuracy(fc_holt, test), Damped = accuracy(fc_dmp, test) )[, c(&quot;ME&quot;,&quot;RMSE&quot;,&quot;MAE&quot;,&quot;MAPE&quot;,&quot;ACF1&quot;)] acc_df &lt;- data.frame(Model = rownames(acc), acc, row.names = NULL) if (requireNamespace(&quot;knitr&quot;, quietly = TRUE)) { knitr::kable(acc_df, digits = 3, caption = &quot;Comparación de modelos ETS (evaluación en log)&quot;) } else { print(acc_df) } Table 2.1: Comparación de modelos ETS (evaluación en log) Model ME RMSE MAE MAPE ACF1 Training set 0.064 0.114 0.095 1.323 0.270 Test set -0.249 0.272 0.249 2.860 -0.001 Training set 0.018 0.091 0.074 1.034 0.008 Test set -0.402 0.425 0.402 4.605 0.184 Training set 0.018 0.091 0.074 1.034 0.008 Test set -0.402 0.425 0.402 4.605 0.184 # --- Selección del mejor por RMSE --- best_name &lt;- acc_df$Model[ which.min(acc_df$RMSE) ] best_fit &lt;- switch(best_name, SES = fit_ses, Holt = fit_holt, Damped = fit_dmp) best_fc &lt;- switch(best_name, SES = fc_ses, Holt = fc_holt, Damped = fc_dmp) best_name # nombre del modelo seleccionado ## [1] &quot;Training set&quot; # --- Gráfico comparativo de pronósticos en nivel (re-exponenciados) --- p_comp &lt;- autoplot(exp(ts_log)) + autolayer(exp(fc_ses$mean), series = &quot;SES&quot;, lwd = 0.9) + autolayer(exp(fc_holt$mean), series = &quot;Holt&quot;, lwd = 0.9) + autolayer(exp(fc_dmp$mean), series = &quot;Holt amortiguado&quot;, lwd = 0.9) + labs(title = &quot;PIB per cápita (Colombia): Suavizamiento exponencial (ETS)&quot;, x = &quot;Año&quot;, y = &quot;US$ por persona (nivel)&quot;) + theme_minimal() print(p_comp) # --- Diagnóstico de residuos (robusto) --- res &lt;- try(residuals(best_fit), silent = TRUE) if (inherits(res, &quot;try-error&quot;) || is.null(res)) { fitted_vals &lt;- try(fitted(best_fit), silent = TRUE) if (!inherits(fitted_vals, &quot;try-error&quot;) &amp;&amp; !is.null(fitted_vals)) { len &lt;- min(length(train), length(fitted_vals)) res &lt;- train[seq_len(len)] - fitted_vals[seq_len(len)] } else { res &lt;- train - mean(train, na.rm = TRUE) # fallback } } res &lt;- as.numeric(na.omit(res)) par(mfrow = c(1,2), mar = c(3,4,2,1)) acf(res, main = paste(&quot;ACF residuos —&quot;, best_name)) pacf(res, main = paste(&quot;PACF residuos —&quot;, best_name)) par(mfrow = c(1,1)) lb &lt;- Box.test(res, lag = min(10, length(res) - 1), type = &quot;Ljung-Box&quot;) lb ## ## Box-Ljung test ## ## data: res ## X-squared = 278.5, df = 10, p-value &lt; 2.2e-16 # --- Pronóstico final del modelo seleccionado (en nivel con intervalos) --- # Construimos los años futuros de forma segura (anual): last_year &lt;- max(gdp_col$year, na.rm = TRUE) years_fc &lt;- last_year + seq_along(best_fc$mean) # Notar: best_fc$lower/upper pueden ser NULL; manejamos con NA seguros. lo80 &lt;- if (!is.null(best_fc$lower) &amp;&amp; &quot;80%&quot; %in% colnames(best_fc$lower)) exp(best_fc$lower[,&quot;80%&quot;]) else rep(NA_real_, length(best_fc$mean)) hi80 &lt;- if (!is.null(best_fc$upper) &amp;&amp; &quot;80%&quot; %in% colnames(best_fc$upper)) exp(best_fc$upper[,&quot;80%&quot;]) else rep(NA_real_, length(best_fc$mean)) lo95 &lt;- if (!is.null(best_fc$lower) &amp;&amp; &quot;95%&quot; %in% colnames(best_fc$lower)) exp(best_fc$lower[,&quot;95%&quot;]) else rep(NA_real_, length(best_fc$mean)) hi95 &lt;- if (!is.null(best_fc$upper) &amp;&amp; &quot;95%&quot; %in% colnames(best_fc$upper)) exp(best_fc$upper[,&quot;95%&quot;]) else rep(NA_real_, length(best_fc$mean)) df_final &lt;- data.frame( Year = years_fc, Mean = exp(as.numeric(best_fc$mean)), Lo80 = as.numeric(lo80), Hi80 = as.numeric(hi80), Lo95 = as.numeric(lo95), Hi95 = as.numeric(hi95) ) p_final &lt;- ggplot() + geom_line(aes(x = gdp_col$year, y = gdp_col$gdp), linewidth = 0.6) + geom_ribbon(data = df_final, aes(x = Year, ymin = Lo95, ymax = Hi95), alpha = .12) + geom_ribbon(data = df_final, aes(x = Year, ymin = Lo80, ymax = Hi80), alpha = .18) + geom_line(data = df_final, aes(x = Year, y = Mean), linewidth = 0.9) + labs(title = paste(&quot;Pronóstico ETS — Modelo seleccionado:&quot;, best_name), x = &quot;Año&quot;, y = &quot;US$ por persona (nivel)&quot;) + theme_minimal() print(p_final) # --- Serie base (Colombia) en log --- if (!exists(&quot;dat_gdp&quot;)) stop(&quot;dat_gdp no existe en el entorno.&quot;) if (!exists(&quot;gdp_col&quot;)) { gdp_col &lt;- dat_gdp %&gt;% filter(country == &quot;Colombia&quot;) %&gt;% arrange(year) } ts_log &lt;- ts(log(gdp_col$gdp), start = min(gdp_col$year, na.rm = TRUE), frequency = 1) # anual # --- Partición entrenamiento/prueba --- n &lt;- length(ts_log) h &lt;- min(10, max(3, floor(n * 0.15))) # horizonte: hasta 10 años, al menos 3 train &lt;- window(ts_log, end = time(ts_log)[n - h]) test &lt;- window(ts_log, start = time(ts_log)[n - h + 1]) # --- Baseline: modelo lineal con tendencia (en log) --- fit_lm &lt;- tslm(train ~ trend) fc_lm &lt;- forecast(fit_lm, h = h) # --- ARIMA automático --- fit_arima &lt;- auto.arima(train, stepwise = FALSE, approximation = FALSE, seasonal = TRUE) fc_arima &lt;- forecast(fit_arima, h = h) # --- Comparación (RMSE/MAE/MAPE) + AIC/BIC de los modelos --- acc_lm &lt;- accuracy(fc_lm, test) acc_arima &lt;- accuracy(fc_arima, test) acc_bj_df &lt;- data.frame( Model = c(&quot;TrendLM&quot;, &quot;ARIMA&quot;), ME = c(acc_lm[&quot;Test set&quot;,&quot;ME&quot;], acc_arima[&quot;Test set&quot;,&quot;ME&quot;]), RMSE = c(acc_lm[&quot;Test set&quot;,&quot;RMSE&quot;], acc_arima[&quot;Test set&quot;,&quot;RMSE&quot;]), MAE = c(acc_lm[&quot;Test set&quot;,&quot;MAE&quot;], acc_arima[&quot;Test set&quot;,&quot;MAE&quot;]), MAPE = c(acc_lm[&quot;Test set&quot;,&quot;MAPE&quot;], acc_arima[&quot;Test set&quot;,&quot;MAPE&quot;]), AIC = c(AIC(fit_lm), AIC(fit_arima)), BIC = c(BIC(fit_lm), BIC(fit_arima)), row.names = NULL ) if (requireNamespace(&quot;knitr&quot;, quietly = TRUE)) { knitr::kable(acc_bj_df, digits = 3, caption = &quot;Comparación Trend vs ARIMA&quot;) } else { print(acc_bj_df) } Table 2.2: Comparación Trend vs ARIMA Model ME RMSE MAE MAPE AIC BIC TrendLM -0.371 0.437 0.398 4.558 -12.588 -6.621 ARIMA -0.560 0.607 0.560 6.409 -98.076 -92.165 # --- Selección del mejor por RMSE (y luego validar residuos) --- best_name &lt;- acc_bj_df$Model[ which.min(acc_bj_df$RMSE) ] best_fit &lt;- if (best_name == &quot;ARIMA&quot;) fit_arima else fit_lm best_fc &lt;- if (best_name == &quot;ARIMA&quot;) fc_arima else fc_lm # --- Diagnóstico de residuos (robusto ante ausencia de residuales) --- try({ checkresiduals(best_fit) }, silent = TRUE) ## ## Breusch-Godfrey test for serial correlation of order up to 10 ## ## data: Residuals from Linear regression model ## LM test = 47.063, df = 10, p-value = 9.196e-07 res &lt;- try(residuals(best_fit), silent = TRUE) if (inherits(res, &quot;try-error&quot;) || is.null(res)) { fitted_vals &lt;- try(fitted(best_fit), silent = TRUE) if (!inherits(fitted_vals, &quot;try-error&quot;) &amp;&amp; !is.null(fitted_vals)) { len &lt;- min(length(train), length(fitted_vals)) res &lt;- train[seq_len(len)] - fitted_vals[seq_len(len)] } else { res &lt;- train - mean(train, na.rm = TRUE) } } res &lt;- as.numeric(na.omit(res)) par(mfrow = c(1,2), mar = c(3,4,2,1)) acf(res, main = paste(&quot;ACF residuos —&quot;, best_name)) pacf(res, main = paste(&quot;PACF residuos —&quot;, best_name)) par(mfrow = c(1,1)) lb &lt;- Box.test(res, lag = min(10, length(res) - 1), type = &quot;Ljung-Box&quot;) lb ## ## Box-Ljung test ## ## data: res ## X-squared = 160.49, df = 10, p-value &lt; 2.2e-16 # --- Gráfico comparativo (en nivel) de ambos pronósticos --- p_comp &lt;- autoplot(exp(ts_log)) + autolayer(exp(fc_lm$mean), series = &quot;Tendencia lineal (log)&quot;, lwd = 0.9) + autolayer(exp(fc_arima$mean), series = &quot;ARIMA (log)&quot;, lwd = 0.9) + labs(title = &quot;PIB per cápita (Colombia): comparación Trend vs ARIMA&quot;, x = &quot;Año&quot;, y = &quot;US$ por persona (nivel)&quot;) + theme_minimal() print(p_comp) # --- Pronóstico final del modelo seleccionado (en nivel con intervalos) --- last_year &lt;- max(gdp_col$year, na.rm = TRUE) years_fc &lt;- last_year + seq_along(best_fc$mean) lo80 &lt;- if (!is.null(best_fc$lower) &amp;&amp; &quot;80%&quot; %in% colnames(best_fc$lower)) exp(best_fc$lower[,&quot;80%&quot;]) else rep(NA_real_, length(best_fc$mean)) hi80 &lt;- if (!is.null(best_fc$upper) &amp;&amp; &quot;80%&quot; %in% colnames(best_fc$upper)) exp(best_fc$upper[,&quot;80%&quot;]) else rep(NA_real_, length(best_fc$mean)) lo95 &lt;- if (!is.null(best_fc$lower) &amp;&amp; &quot;95%&quot; %in% colnames(best_fc$lower)) exp(best_fc$lower[,&quot;95%&quot;]) else rep(NA_real_, length(best_fc$mean)) hi95 &lt;- if (!is.null(best_fc$upper) &amp;&amp; &quot;95%&quot; %in% colnames(best_fc$upper)) exp(best_fc$upper[,&quot;95%&quot;]) else rep(NA_real_, length(best_fc$mean)) df_final &lt;- data.frame( Year = years_fc, Mean = exp(as.numeric(best_fc$mean)), Lo80 = as.numeric(lo80), Hi80 = as.numeric(hi80), Lo95 = as.numeric(lo95), Hi95 = as.numeric(hi95) ) # Etiqueta ARIMA (p,d,q)(P,D,Q)[m] ord &lt;- arimaorder(fit_arima) # c(p,d,q,P,D,Q,m) lab_arima &lt;- if (!is.na(ord[4]) &amp;&amp; ord[7] &gt; 1) { sprintf(&quot;ARIMA(%d,%d,%d)(%d,%d,%d)[%d]&quot;, ord[1], ord[2], ord[3], ord[4], ord[5], ord[6], ord[7]) } else { sprintf(&quot;ARIMA(%d,%d,%d)&quot;, ord[1], ord[2], ord[3]) } p_final &lt;- ggplot() + geom_line(aes(x = gdp_col$year, y = gdp_col$gdp), linewidth = 0.6) + geom_ribbon(data = df_final, aes(x = Year, ymin = Lo95, ymax = Hi95), alpha = .12) + geom_ribbon(data = df_final, aes(x = Year, ymin = Lo80, ymax = Hi80), alpha = .18) + geom_line(data = df_final, aes(x = Year, y = Mean), linewidth = 0.9) + labs(title = paste(&quot;Pronóstico final — modelo seleccionado:&quot;, if (best_name==&quot;ARIMA&quot;) lab_arima else &quot;Tendencia lineal&quot;), x = &quot;Año&quot;, y = &quot;US$ por persona (nivel)&quot;) + theme_minimal() print(p_final) ## Warning: Removed 9 rows containing missing values or values outside the scale range ## (`geom_ribbon()`). ## Removed 9 rows containing missing values or values outside the scale range ## (`geom_ribbon()`). "]]
