---
title: "Unidad 2 — Análisis temporal (PIB per cápita) + CO₂ opcional"
output:
  pdf_document: default
  html_document: default
---

# Unidad 2 — Análisis temporal (PIB per cápita)

En esta unidad se realiza un análisis exploratorio de **PIB per cápita** (Banco Mundial, 1960–2022) para países LATAM (COL, MEX, BRA, CHL, ARG), con:
- **Promedio móvil** (suavizamiento),
- **Rezagos** y **ACF** (dependencia temporal),
- Discusión de **estacionalidad** (serie anual, no hay estacionalidad intra-anual).

> **Nota:** El API del Banco Mundial está devolviendo intermitentemente “indicator not found” para CO₂. Para no bloquear la entrega, la serie principal de la Unidad 2 será **PIB per cápita** (`NY.GDP.PCAP.CD`). Al final añadimos un **chunk opcional** que intenta traer **CO₂ per cápita** (`EN.ATM.CO2E.PC`) con códigos de país **en mayúsculas**; si funciona, se muestra un gráfico **PIB–CO₂** como “tiempo variable complementaria”. Si no, la compilación no se rompe.

---

## Librerías

```{r setup, message=FALSE, warning=FALSE}
library(WDI)        # fuente Banco Mundial (WDI)
library(wbstats)    # otra interfaz al API del Banco Mundial
library(dplyr)
library(ggplot2)
library(zoo)
library(forecast)
```

## Descarga y preparación de PIB per cápita (serie estable)
```{r, echo=TRUE,include=TRUE}
# Descargar PIB per cápita (US$ actuales) por país, garantizando MAYÚSCULAS

paises <- c("COL","MEX","BRA","CHL","ARG")
years  <- 1960:2022

get_gdp_pc <- function(cc) {
WDI(country = toupper(cc),
indicator = c(gdp = "NY.GDP.PCAP.CD"),
start = min(years), end = max(years))
}

lst_gdp <- lapply(paises, get_gdp_pc)
dat_gdp <- bind_rows(lst_gdp)

# Limpiar y ordenar

dat_gdp <- dat_gdp %>%
transmute(country, iso2c, iso3c,
year = as.integer(year),
gdp) %>%
arrange(country, year)

# Verificación rápida

stopifnot("gdp" %in% names(dat_gdp))
head(dat_gdp)
range(dat_gdp$year)

```

## Serie principal (Colombia) y gráfico base


```{r, echo=TRUE,include=TRUE}
gdp_col <- dat_gdp %>%
filter(country == "Colombia") %>%
arrange(year)

ggplot(gdp_col, aes(year, gdp)) +
geom_line(linewidth = 1, color = "steelblue") +
geom_point(size = 1.5) +
labs(title = "PIB per cápita — Colombia (1960–2022)",
x = "Año", y = "US$ actuales por persona") +
theme_minimal()

```

## Promedio móvil (suavizamiento)
```{r, echo=TRUE,include=TRUE}
gdp_col <- gdp_col %>%
mutate(ma5 = zoo::rollmean(gdp, k = 5, fill = NA, align = "right"))

ggplot(gdp_col, aes(year)) +
geom_line(aes(y = gdp), color = "gray60") +
geom_line(aes(y = ma5), color = "red", linewidth = 1) +
labs(title = "PIB per cápita y promedio móvil (5 años)",
x = "Año", y = "US$ actuales por persona") +
theme_minimal()
```

## Rezagos y ACF (dependencia temporal)
```{r, echo=TRUE,include=TRUE}
gdp_col <- gdp_col %>%
mutate(gdp_lag1 = dplyr::lag(gdp, 1))

ggplot(gdp_col, aes(gdp_lag1, gdp)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red") +
labs(title = "PIB per cápita: gdp(t) vs gdp(t−1)",
x = "PIB per cápita año t−1", y = "PIB per cápita año t") +
theme_minimal()

ts_gdp <- ts(gdp_col$gdp, start = min(gdp_col$year), frequency = 1)
acf(ts_gdp, main = "ACF — PIB per cápita (anual)")
```

## Estacionalidad (discusión)
La serie es anual (frecuencia 1), por lo que no existe estacionalidad intra-anual.
La dinámica observable es de tendencia/ciclos de largo plazo. Para estacionalidad clásica se requerirían datos mensuales o trimestrales.
## Tiempo como variable complementaria: PIB vs CO₂
```{r, echo=TRUE,include=TRUE}
# Tiempo como variable complementaria: PIB vs CO₂

show_co2_plot <- FALSE

# Intento 1: CO₂ per cápita directo por país (códigos MAYÚSCULAS)

safe_get_pc <- function(cc) {
try(
wb_data(
indicator   = c(co2 = "EN.ATM.CO2E.PC"),
country     = toupper(cc),
start_date  = min(years),
end_date    = max(years),
return_wide = TRUE
),
silent = TRUE
)
}

lst_co2 <- lapply(paises, safe_get_pc)

# Validar que al menos uno devolvió 'co2' con datos no-NA

valid_frames <- lapply(lst_co2, function(x) {
is.data.frame(x) && "co2" %in% names(x) && any(!is.na(x$co2))
})

if (any(unlist(valid_frames))) {
co2_ok <- bind_rows(lst_co2[unlist(valid_frames)]) %>%
transmute(country, iso2c, iso3c,
year = as.integer(date),
co2) %>%
arrange(country, year)

# Unir con PIB

dat_join <- inner_join(co2_ok, dat_gdp,
by = c("country","iso2c","iso3c","year"))
if (nrow(dat_join) > 0) {
show_co2_plot <- TRUE
co2_countries <- intersect(unique(dat_join$country), unique(dat_gdp$country))
# message("CO₂ disponible para: ", paste(co2_countries, collapse = ", "))


ggplot(dat_join %>% filter(country %in% co2_countries),
       aes(gdp, co2, group = country, color = year)) +
  geom_path(linewidth = 1) +
  scale_x_log10() +
  labs(title = "PIB per cápita vs CO₂ per cápita (si API responde)",
       x = "PIB per cápita (US$ actuales, log)",
       y = "CO₂ per cápita (t/persona·año)") +
  theme_minimal()


}
}

if (!show_co2_plot) {
message("No se pudo obtener CO₂ per cápita en este intento; el análisis principal usa PIB per cápita.")
}
```


```{r, echo=TRUE, include=TRUE}
# Descomposición (anual sin estacionalidad), estacionariedad y diferenciación

# Cargar paquetes (asegúrate de tenerlos instalados previamente)
library(tseries)
library(urca)
library(dplyr)

# 1) Serie de Colombia en log (control de variabilidad)
if (!exists("gdp_col")) {
  gdp_col <- dat_gdp %>%
    filter(country == "Colombia") %>%
    arrange(year)
}

gdp_col <- gdp_col %>% mutate(log_gdp = log(gdp))
ts_log  <- ts(gdp_col$log_gdp,
              start = min(gdp_col$year, na.rm = TRUE),
              frequency = 1)  # anual ⇒ sin estacionalidad

# 2) "Descomposición" compatible con frecuencia 1:
#    Tendencia por LOESS + Residuo = log(PIB) - Tendencia
df_loess <- data.frame(year = gdp_col$year, log_gdp = as.numeric(ts_log))
fit      <- loess(log_gdp ~ year, data = df_loess, span = 0.3, degree = 1)
trend    <- ts(predict(fit, newdata = df_loess),
               start = start(ts_log), frequency = frequency(ts_log))
remainder <- ts_log - trend

# Gráfico de los tres componentes
op <- par(mfrow = c(3,1), mar = c(3,4,2,1))
plot(ts_log,    main = "log(PIB per cápita) — Colombia", ylab = "log(US$)")
plot(trend,     main = "Tendencia (LOESS)",              ylab = "log(US$)")
plot(remainder, main = "Residuo",                        ylab = "log(US$)")
par(op)

# 3) Estacionariedad (log nivel)
adf_log  <- tseries::adf.test(na.omit(ts_log), k = 1)        # H0: raíz unitaria
kpss_log <- urca::ur.kpss(na.omit(ts_log), type = "tau")     # H0: estacionaria (tendencia)

list(
  ADF_p_value_log   = adf_log$p.value,
  KPSS_stat_log     = kpss_log@teststat,
  KPSS_critical_log = kpss_log@cval
)

# 4) Diferenciación (Δlog ⇒ aprox. crecimiento %)
diff_log <- diff(ts_log)

op <- par(mfrow = c(2,2), mar = c(3,4,2,1))
plot(ts_log,   main = "Serie log(PIB pc)",     ylab = "log(US$)")
plot(diff_log, main = "Primera diferencia",    ylab = "Δlog(US$)")
acf (diff_log, main = "ACF Δlog(PIB pc)")
pacf(diff_log, main = "PACF Δlog(PIB pc)")
par(op)

# 5) Estacionariedad (serie diferenciada)
adf_diff  <- tseries::adf.test(na.omit(diff_log), k = 1)
kpss_diff <- urca::ur.kpss(na.omit(diff_log), type = "mu")    # H0: estacionaria (nivel)

list(
  ADF_p_value_diff   = adf_diff$p.value,
  KPSS_stat_diff     = kpss_diff@teststat,
  KPSS_critical_diff = kpss_diff@cval
)
```


- **Descomposición:** al ser anual (**frecuencia = 1**), **no existe estacionalidad**. Se estimó una **tendencia** mediante LOESS y se definió el **residuo** como la parte no explicada por la tendencia.  
- **Estacionariedad:** en **log(nivel)** la serie no es estacionaria (tendencia marcada; ADF no rechaza H0 y/o KPSS rechaza H0 al 5%).  
- **Diferenciación:** con **Δlog** la serie se vuelve compatible con estacionariedad (ADF rechaza H0 y KPSS no rechaza H0).  
- **Transformaciones necesarias:** **log** para estabilizar variabilidad y **diferencia de orden 1** para remover tendencia; esto prepara la serie para modelos ARIMA/ETS.

**Conclusiones:**

La serie anual de PIB per cápita presenta una tendencia creciente sostenida y no muestra estacionalidad al ser de frecuencia 1 (anual).

Se aplicó una transformación logarítmica para estabilizar la varianza y expresar la dinámica en términos relativos (proporcionales).

Las pruebas ADF y KPSS confirman que la serie no es estacionaria en niveles, pero sí lo es tras una primera diferenciación del logaritmo, que equivale al crecimiento porcentual anual del PIB per cápita.

Por tanto, las transformaciones log() y Δlog() son necesarias y justificadas para preparar la serie hacia modelado ARIMA/ETS.

El análisis indica que la estructura temporal del PIB per cápita colombiano está dominada por una tendencia de largo plazo asociada a crecimiento económico, sin evidencia de ciclos regulares o estacionalidad recurrente.

```{r, echo=TRUE, include=TRUE}
# --- Serie base (Colombia) en log para estabilizar variabilidad ---
if (!exists("dat_gdp")) stop("dat_gdp no existe en el entorno.")
if (!exists("gdp_col")) {
  gdp_col <- dat_gdp %>% filter(country == "Colombia") %>% arrange(year)
}
ts_log <- ts(log(gdp_col$gdp),
             start = min(gdp_col$year, na.rm = TRUE),
             frequency = 1)  # anual (sin estacionalidad intra-anual)

# --- Partición entrenamiento/prueba ---
n <- length(ts_log)
h <- min(10, max(3, floor(n * 0.15)))  # horizonte: hasta 10 años, al menos 3
train <- window(ts_log, end = time(ts_log)[n - h])
test  <- window(ts_log, start = time(ts_log)[n - h + 1])

# --- Modelos ETS sin estacionalidad ---
fit_ses  <- ets(train, model = "ANN")                   # SES
fit_holt <- ets(train, model = "AAN")                   # Holt (tendencia)
fit_dmp  <- ets(train, model = "AAN", damped = TRUE)    # Holt amortiguado (damped)

# --- Pronósticos ---
fc_ses   <- forecast(fit_ses,  h = h)
fc_holt  <- forecast(fit_holt, h = h)
fc_dmp   <- forecast(fit_dmp,  h = h)

# --- Métricas de evaluación (en log) ---
acc <- rbind(
  SES    = accuracy(fc_ses,  test),
  Holt   = accuracy(fc_holt, test),
  Damped = accuracy(fc_dmp,  test)
)[, c("ME","RMSE","MAE","MAPE","ACF1")]
acc_df <- data.frame(Model = rownames(acc), acc, row.names = NULL)

if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(acc_df, digits = 3, caption = "Comparación de modelos ETS (evaluación en log)")
} else {
  print(acc_df)
}

# --- Selección del mejor por RMSE ---
best_name <- acc_df$Model[ which.min(acc_df$RMSE) ]
best_fit  <- switch(best_name,
                    SES    = fit_ses,
                    Holt   = fit_holt,
                    Damped = fit_dmp)
best_fc   <- switch(best_name,
                    SES    = fc_ses,
                    Holt   = fc_holt,
                    Damped = fc_dmp)

best_name  # nombre del modelo seleccionado

# --- Gráfico comparativo de pronósticos en nivel (re-exponenciados) ---
p_comp <- autoplot(exp(ts_log)) +
  autolayer(exp(fc_ses$mean),  series = "SES",               lwd = 0.9) +
  autolayer(exp(fc_holt$mean), series = "Holt",              lwd = 0.9) +
  autolayer(exp(fc_dmp$mean),  series = "Holt amortiguado",  lwd = 0.9) +
  labs(title = "PIB per cápita (Colombia): Suavizamiento exponencial (ETS)",
       x = "Año", y = "US$ por persona (nivel)") +
  theme_minimal()
print(p_comp)

# --- Diagnóstico de residuos (robusto) ---
res <- try(residuals(best_fit), silent = TRUE)
if (inherits(res, "try-error") || is.null(res)) {
  fitted_vals <- try(fitted(best_fit), silent = TRUE)
  if (!inherits(fitted_vals, "try-error") && !is.null(fitted_vals)) {
    len <- min(length(train), length(fitted_vals))
    res <- train[seq_len(len)] - fitted_vals[seq_len(len)]
  } else {
    res <- train - mean(train, na.rm = TRUE)  # fallback
  }
}
res <- as.numeric(na.omit(res))

par(mfrow = c(1,2), mar = c(3,4,2,1))
acf(res,  main = paste("ACF residuos —", best_name))
pacf(res, main = paste("PACF residuos —", best_name))
par(mfrow = c(1,1))

lb <- Box.test(res, lag = min(10, length(res) - 1), type = "Ljung-Box")
lb

# --- Pronóstico final del modelo seleccionado (en nivel con intervalos) ---
# Construimos los años futuros de forma segura (anual):
last_year <- max(gdp_col$year, na.rm = TRUE)
years_fc  <- last_year + seq_along(best_fc$mean)

# Notar: best_fc$lower/upper pueden ser NULL; manejamos con NA seguros.
lo80 <- if (!is.null(best_fc$lower) && "80%" %in% colnames(best_fc$lower)) exp(best_fc$lower[,"80%"]) else rep(NA_real_, length(best_fc$mean))
hi80 <- if (!is.null(best_fc$upper) && "80%" %in% colnames(best_fc$upper)) exp(best_fc$upper[,"80%"]) else rep(NA_real_, length(best_fc$mean))
lo95 <- if (!is.null(best_fc$lower) && "95%" %in% colnames(best_fc$lower)) exp(best_fc$lower[,"95%"]) else rep(NA_real_, length(best_fc$mean))
hi95 <- if (!is.null(best_fc$upper) && "95%" %in% colnames(best_fc$upper)) exp(best_fc$upper[,"95%"]) else rep(NA_real_, length(best_fc$mean))

df_final <- data.frame(
  Year = years_fc,
  Mean = exp(as.numeric(best_fc$mean)),
  Lo80 = as.numeric(lo80),
  Hi80 = as.numeric(hi80),
  Lo95 = as.numeric(lo95),
  Hi95 = as.numeric(hi95)
)

p_final <- ggplot() +
  geom_line(aes(x = gdp_col$year, y = gdp_col$gdp), linewidth = 0.6) +
  geom_ribbon(data = df_final, aes(x = Year, ymin = Lo95, ymax = Hi95), alpha = .12) +
  geom_ribbon(data = df_final, aes(x = Year, ymin = Lo80, ymax = Hi80), alpha = .18) +
  geom_line(data = df_final, aes(x = Year, y = Mean), linewidth = 0.9) +
  labs(title = paste("Pronóstico ETS — Modelo seleccionado:", best_name),
       x = "Año", y = "US$ por persona (nivel)") +
  theme_minimal()
print(p_final)
```
```{r, echo=TRUE, include=TRUE}
# --- Serie base (Colombia) en log ---
if (!exists("dat_gdp")) stop("dat_gdp no existe en el entorno.")
if (!exists("gdp_col")) {
  gdp_col <- dat_gdp %>% filter(country == "Colombia") %>% arrange(year)
}
ts_log <- ts(log(gdp_col$gdp),
             start = min(gdp_col$year, na.rm = TRUE),
             frequency = 1)  # anual

# --- Partición entrenamiento/prueba ---
n <- length(ts_log)
h <- min(10, max(3, floor(n * 0.15)))  # horizonte: hasta 10 años, al menos 3
train <- window(ts_log, end = time(ts_log)[n - h])
test  <- window(ts_log, start = time(ts_log)[n - h + 1])

# --- Baseline: modelo lineal con tendencia (en log) ---
fit_lm <- tslm(train ~ trend)
fc_lm  <- forecast(fit_lm, h = h)

# --- ARIMA automático ---
fit_arima <- auto.arima(train, stepwise = FALSE, approximation = FALSE, seasonal = TRUE)
fc_arima  <- forecast(fit_arima, h = h)

# --- Comparación (RMSE/MAE/MAPE) + AIC/BIC de los modelos ---
acc_lm    <- accuracy(fc_lm,    test)
acc_arima <- accuracy(fc_arima, test)

acc_bj_df <- data.frame(
  Model = c("TrendLM", "ARIMA"),
  ME    = c(acc_lm["Test set","ME"],    acc_arima["Test set","ME"]),
  RMSE  = c(acc_lm["Test set","RMSE"],  acc_arima["Test set","RMSE"]),
  MAE   = c(acc_lm["Test set","MAE"],   acc_arima["Test set","MAE"]),
  MAPE  = c(acc_lm["Test set","MAPE"],  acc_arima["Test set","MAPE"]),
  AIC   = c(AIC(fit_lm),                AIC(fit_arima)),
  BIC   = c(BIC(fit_lm),                BIC(fit_arima)),
  row.names = NULL
)

if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::kable(acc_bj_df, digits = 3, caption = "Comparación Trend vs ARIMA")
} else {
  print(acc_bj_df)
}

# --- Selección del mejor por RMSE (y luego validar residuos) ---
best_name <- acc_bj_df$Model[ which.min(acc_bj_df$RMSE) ]
best_fit  <- if (best_name == "ARIMA") fit_arima else fit_lm
best_fc   <- if (best_name == "ARIMA") fc_arima  else fc_lm

# --- Diagnóstico de residuos (robusto ante ausencia de residuales) ---
try({ checkresiduals(best_fit) }, silent = TRUE)

res <- try(residuals(best_fit), silent = TRUE)
if (inherits(res, "try-error") || is.null(res)) {
  fitted_vals <- try(fitted(best_fit), silent = TRUE)
  if (!inherits(fitted_vals, "try-error") && !is.null(fitted_vals)) {
    len <- min(length(train), length(fitted_vals))
    res <- train[seq_len(len)] - fitted_vals[seq_len(len)]
  } else {
    res <- train - mean(train, na.rm = TRUE)
  }
}
res <- as.numeric(na.omit(res))

par(mfrow = c(1,2), mar = c(3,4,2,1))
acf(res,  main = paste("ACF residuos —", best_name))
pacf(res, main = paste("PACF residuos —", best_name))
par(mfrow = c(1,1))
lb <- Box.test(res, lag = min(10, length(res) - 1), type = "Ljung-Box")
lb

# --- Gráfico comparativo (en nivel) de ambos pronósticos ---
p_comp <- autoplot(exp(ts_log)) +
  autolayer(exp(fc_lm$mean),    series = "Tendencia lineal (log)", lwd = 0.9) +
  autolayer(exp(fc_arima$mean), series = "ARIMA (log)",             lwd = 0.9) +
  labs(title = "PIB per cápita (Colombia): comparación Trend vs ARIMA",
       x = "Año", y = "US$ por persona (nivel)") +
  theme_minimal()
print(p_comp)

# --- Pronóstico final del modelo seleccionado (en nivel con intervalos) ---
last_year <- max(gdp_col$year, na.rm = TRUE)
years_fc  <- last_year + seq_along(best_fc$mean)

lo80 <- if (!is.null(best_fc$lower) && "80%" %in% colnames(best_fc$lower)) exp(best_fc$lower[,"80%"]) else rep(NA_real_, length(best_fc$mean))
hi80 <- if (!is.null(best_fc$upper) && "80%" %in% colnames(best_fc$upper)) exp(best_fc$upper[,"80%"]) else rep(NA_real_, length(best_fc$mean))
lo95 <- if (!is.null(best_fc$lower) && "95%" %in% colnames(best_fc$lower)) exp(best_fc$lower[,"95%"]) else rep(NA_real_, length(best_fc$mean))
hi95 <- if (!is.null(best_fc$upper) && "95%" %in% colnames(best_fc$upper)) exp(best_fc$upper[,"95%"]) else rep(NA_real_, length(best_fc$mean))

df_final <- data.frame(
  Year = years_fc,
  Mean = exp(as.numeric(best_fc$mean)),
  Lo80 = as.numeric(lo80),
  Hi80 = as.numeric(hi80),
  Lo95 = as.numeric(lo95),
  Hi95 = as.numeric(hi95)
)

# Etiqueta ARIMA (p,d,q)(P,D,Q)[m]
ord <- arimaorder(fit_arima)       # c(p,d,q,P,D,Q,m)
lab_arima <- if (!is.na(ord[4]) && ord[7] > 1) {
  sprintf("ARIMA(%d,%d,%d)(%d,%d,%d)[%d]", ord[1], ord[2], ord[3], ord[4], ord[5], ord[6], ord[7])
} else {
  sprintf("ARIMA(%d,%d,%d)", ord[1], ord[2], ord[3])
}

p_final <- ggplot() +
  geom_line(aes(x = gdp_col$year, y = gdp_col$gdp), linewidth = 0.6) +
  geom_ribbon(data = df_final, aes(x = Year, ymin = Lo95, ymax = Hi95), alpha = .12) +
  geom_ribbon(data = df_final, aes(x = Year, ymin = Lo80, ymax = Hi80), alpha = .18) +
  geom_line(data = df_final, aes(x = Year, y = Mean), linewidth = 0.9) +
  labs(title = paste("Pronóstico final — modelo seleccionado:", if (best_name=="ARIMA") lab_arima else "Tendencia lineal"),
       x = "Año", y = "US$ por persona (nivel)") +
  theme_minimal()
print(p_final)
```


